# 🚀 NSFW Phase 1: Foundation (Weeks 1-2)

**Duration**: 2 weeks
**Environment**: NixOS only (no Windows needed!)
**Goal**: Build core architecture that will run on Windows via WSL2

---

## 📋 Overview

Phase 1 establishes the foundational architecture for NSFW:
- Core CLI in Rust
- Nix operations layer (search, install, remove)
- Path translation logic with unit tests
- Wrapper script templates
- WSL2 bridge design (implementation in Phase 2)

**All work can be done on NixOS.** Windows testing begins in Phase 2.

---

## 🎯 Week 1: Core Architecture (Days 1-7)

### Day 1-2: Repository Setup & CLI Skeleton

**Goal**: Get a working "Hello World" CLI that can be extended

**Tasks**:
- [x] Initialize Git repository
- [x] Create Rust project with Cargo
- [ ] Set up Nix flake for development environment
- [ ] Create basic CLI with `clap` (Rust arg parser)
- [ ] Implement subcommands: `install`, `search`, `remove`, `list`
- [ ] Add `--help` and `--version` flags
- [ ] Write README with quick start guide

**Deliverable**: `nsfw --help` works and shows all subcommands

**Testing**:
```bash
cargo build
./target/debug/nsfw --help
./target/debug/nsfw search firefox  # Stub: "Search not implemented yet"
```

### Day 3-4: Nix Operations Layer

**Goal**: Implement actual Nix package operations using subprocess

**Tasks**:
- [ ] Create `NixExecutor` struct in `src/nix_ops/executor.rs`
- [ ] Implement `search()` - calls `nix search nixpkgs <query> --json`
- [ ] Implement `install()` - calls `nix profile install nixpkgs#<package>`
- [ ] Implement `remove()` - calls `nix profile remove <package>`
- [ ] Implement `list()` - calls `nix profile list --json`
- [ ] Add error handling (package not found, network errors, etc.)
- [ ] Parse JSON output from Nix commands

**Deliverable**: Can search and see package results (on NixOS)

**Testing**:
```bash
cargo test
cargo run -- search firefox  # Shows real results from nixpkgs
cargo run -- list           # Shows installed packages
```

### Day 5-7: Path Translation Logic

**Goal**: Build bidirectional path translator (Linux ↔ Windows)

**Tasks**:
- [ ] Create `PathTranslator` struct in `src/path_translation/translator.rs`
- [ ] Implement Linux → Windows translation (`/nix/store` → `C:\Nix\store`)
- [ ] Implement Windows → Linux translation (`C:\Users` → `/mnt/c/Users`)
- [ ] Handle edge cases:
  - Drive letters (C:, D:, etc.)
  - UNC paths (\\server\share)
  - Relative vs absolute paths
  - Path separators (/ vs \)
- [ ] Write comprehensive unit tests (50+ test cases)
- [ ] Add validation (detect invalid paths)

**Deliverable**: Path translator with 100% test coverage

**Testing**:
```bash
cargo test path_translation  # All tests pass
```

**Example test cases**:
```rust
#[test]
fn test_nix_store_translation() {
    let translator = PathTranslator::new();
    assert_eq!(
        translator.linux_to_windows("/nix/store/abc-firefox"),
        "C:\\Nix\\store\\abc-firefox"
    );
}

#[test]
fn test_home_directory() {
    assert_eq!(
        translator.linux_to_windows("/home/user/project"),
        "C:\\Users\\user\\project"  // Assuming standard mapping
    );
}

#[test]
fn test_wsl_mount_point() {
    assert_eq!(
        translator.windows_to_linux("C:\\Projects\\code"),
        "/mnt/c/Projects/code"
    );
}
```

---

## 🎯 Week 2: Templates & Bridge Design (Days 8-14)

### Day 8-10: Wrapper Script Templates

**Goal**: Create templates for Windows wrapper scripts

**Tasks**:
- [ ] Create `WrapperGenerator` in `src/templates/wrapper.rs`
- [ ] Design .bat file template for console apps
- [ ] Design .bat file template for GUI apps
- [ ] Add support for passing arguments (`%*`)
- [ ] Add support for environment variables
- [ ] Generate shortcut (.lnk) metadata (for Start Menu)
- [ ] Write tests for template generation

**Deliverable**: Can generate wrapper scripts (not execute yet)

**Testing**:
```bash
cargo test templates
cargo run -- generate-wrapper firefox  # Creates .bat file content
```

**Example wrapper output** (firefox.bat):
```batch
@echo off
REM NSFW Wrapper for firefox
REM Generated by nsfw v0.1.0

SET NSFW_PACKAGE_PATH=C:\Nix\store\abc-firefox-130.0
SET PATH=%NSFW_PACKAGE_PATH%\bin;%PATH%

REM Execute via WSL2 bridge
wsl -d NSFW -e %NSFW_PACKAGE_PATH%\bin\firefox %*
```

### Day 11-12: WSL2 Bridge Design

**Goal**: Design the architecture for WSL2 ↔ Windows communication

**Tasks**:
- [ ] Document WSL2 bridge architecture in `docs/WSL2_BRIDGE_DESIGN.md`
- [ ] Design command protocol (how Windows CLI talks to WSL2)
- [ ] Design response format (JSON? Plain text?)
- [ ] Plan error handling across WSL2 boundary
- [ ] Design state management (which WSL2 distro? how to install?)
- [ ] Create mock WSL2 interface for testing (no real WSL2 needed yet)

**Deliverable**: Complete architecture document + mock implementation

**Architecture diagram**:
```
┌─────────────────────────────────────┐
│  Windows (PowerShell/CMD)           │
│                                     │
│  ┌───────────────────────────────┐ │
│  │  nsfw.exe (Rust binary)       │ │
│  │  - Parse CLI args             │ │
│  │  - Translate paths            │ │
│  │  - Call WSL2 bridge           │ │
│  └───────────┬───────────────────┘ │
│              │                      │
│  ┌───────────▼───────────────────┐ │
│  │  WSL Bridge                   │ │
│  │  - Execute: wsl -d NSFW -e   │ │
│  │  - Capture output             │ │
│  │  - Parse JSON response        │ │
│  └───────────┬───────────────────┘ │
└──────────────┼─────────────────────┘
               │
        ┌──────▼──────┐
        │   WSL2      │
        │             │
        │  Nix Daemon │
        └─────────────┘
```

### Day 13-14: Integration & Documentation

**Goal**: Bring it all together and document everything

**Tasks**:
- [ ] Integrate all components into main CLI
- [ ] Write end-to-end tests (using mocks, no real Windows)
- [ ] Document code with rustdoc comments
- [ ] Generate API documentation (`cargo doc`)
- [ ] Write development guide (`docs/DEVELOPMENT.md`)
- [ ] Update README with Phase 1 achievements
- [ ] Create Phase 2 preparation checklist

**Deliverable**: Complete Phase 1 package ready for Windows testing

**Testing**:
```bash
cargo test --all          # All unit tests pass
cargo doc --open          # Documentation generated
cargo build --release     # Release build works
```

---

## 📦 Deliverables Checklist

### Code
- [ ] Working Rust CLI with all subcommands
- [ ] Nix operations layer (search, install, remove, list)
- [ ] Path translation with 100% test coverage
- [ ] Wrapper script generator
- [ ] WSL2 bridge architecture (design only)

### Tests
- [ ] 50+ unit tests (path translation)
- [ ] 20+ integration tests (mocked)
- [ ] 100% coverage for critical paths
- [ ] All tests passing

### Documentation
- [ ] API documentation (rustdoc)
- [ ] Development guide
- [ ] WSL2 bridge design doc
- [ ] Phase 2 preparation guide
- [ ] Updated README

---

## 🏗️ Project Structure (After Phase 1)

```
nsfw/
├── Cargo.toml                    # Rust dependencies
├── flake.nix                     # Nix development environment
├── README.md                     # Quick start guide
│
├── src/
│   ├── main.rs                   # CLI entry point
│   ├── cli/
│   │   ├── mod.rs                # CLI module
│   │   ├── commands.rs           # Command handlers
│   │   └── args.rs               # Argument parsing
│   ├── nix_ops/
│   │   ├── mod.rs
│   │   ├── executor.rs           # Nix command executor
│   │   ├── parser.rs             # JSON response parser
│   │   └── errors.rs             # Error types
│   ├── path_translation/
│   │   ├── mod.rs
│   │   ├── translator.rs         # Path translator
│   │   └── validator.rs          # Path validation
│   ├── wsl_bridge/
│   │   ├── mod.rs
│   │   ├── interface.rs          # WSL2 interface (mock)
│   │   └── protocol.rs           # Command protocol
│   └── templates/
│       ├── mod.rs
│       ├── wrapper.rs            # Wrapper generator
│       └── shortcut.rs           # Shortcut metadata
│
├── tests/
│   ├── unit/
│   │   ├── path_translation_tests.rs
│   │   ├── nix_ops_tests.rs
│   │   └── template_tests.rs
│   └── integration/
│       ├── cli_tests.rs
│       └── end_to_end_tests.rs
│
├── docs/
│   ├── PHASE_1_PLAN.md           # This document
│   ├── PHASE_2_PREP.md           # Next steps
│   ├── WSL2_BRIDGE_DESIGN.md     # Architecture design
│   ├── DEVELOPMENT.md            # Dev guide
│   └── API.md                    # API documentation
│
└── examples/
    ├── search_example.rs
    ├── install_example.rs
    └── wrapper_example.rs
```

---

## 🧪 Testing Strategy (Phase 1)

### Unit Tests (50+ tests)
**Focus**: Individual functions and modules

**Coverage**:
- Path translation: 30 tests (edge cases, validation)
- Nix operations: 10 tests (mocked subprocess)
- Wrapper generation: 10 tests (template rendering)
- Error handling: 10 tests (all error paths)

**Run**: `cargo test --lib`

### Integration Tests (20+ tests)
**Focus**: Component interaction

**Coverage**:
- CLI to Nix operations: 5 tests
- Path translation in context: 5 tests
- End-to-end workflows (mocked): 10 tests

**Run**: `cargo test --test '*'`

### Manual Testing
**Focus**: User experience

**Test cases**:
1. Run `nsfw search firefox` → See results
2. Run `nsfw install hello` → See installation (on NixOS)
3. Run `nsfw list` → See installed packages
4. Run `nsfw remove hello` → See removal
5. Generate wrapper → Inspect .bat file

---

## 📈 Success Metrics (Phase 1)

### Technical
- [ ] 100+ tests written and passing
- [ ] 80%+ code coverage
- [ ] 0 clippy warnings (`cargo clippy`)
- [ ] 0 rustfmt issues (`cargo fmt --check`)
- [ ] Builds in <30s (`cargo build --release`)

### Functional
- [ ] All CLI commands work (with mock/real Nix)
- [ ] Path translator handles 50+ test cases
- [ ] Wrapper generator creates valid .bat files
- [ ] Documentation is comprehensive

### Quality
- [ ] Code is well-organized and readable
- [ ] All public APIs documented
- [ ] Error messages are helpful
- [ ] Logging is informative

---

## 🔧 Development Environment

### Prerequisites
- Rust 1.70+ (via rustup or Nix)
- Nix 2.28+ (for testing Nix operations)
- Git

### Setup
```bash
cd /srv/luminous-dynamics/11-meta-consciousness/nsfw

# Option 1: Use Nix flake
nix develop
cargo build
cargo test

# Option 2: Use system Rust
cargo build
cargo test

# Format code
cargo fmt

# Check for issues
cargo clippy

# Generate docs
cargo doc --open
```

---

## 🚀 Transition to Phase 2

### Phase 2 Preparation Checklist
- [ ] All Phase 1 deliverables complete
- [ ] Code reviewed and merged
- [ ] Documentation reviewed
- [ ] Windows VM set up (or dual-boot ready)
- [ ] WSL2 installed in Windows
- [ ] Nix installed in WSL2

### What Changes in Phase 2
**Phase 1** (Now): Mock WSL2, test on NixOS
**Phase 2** (Next): Real WSL2, test on Windows

**Key transition**:
```rust
// Phase 1: Mock
struct MockWSLBridge;
impl WSLBridge for MockWSLBridge {
    fn execute(&self, cmd: &str) -> Result<String> {
        // Simulate WSL2 call
        Ok("mock output".to_string())
    }
}

// Phase 2: Real
struct RealWSLBridge;
impl WSLBridge for RealWSLBridge {
    fn execute(&self, cmd: &str) -> Result<String> {
        // Actually call wsl.exe
        let output = Command::new("wsl")
            .args(&["-d", "NSFW", "-e", cmd])
            .output()?;
        Ok(String::from_utf8(output.stdout)?)
    }
}
```

---

## 💡 Tips for Phase 1 Development

### 1. Test-Driven Development
Write tests first, then implement:
```rust
#[test]
fn test_search_firefox() {
    let executor = NixExecutor::new();
    let results = executor.search("firefox").unwrap();
    assert!(results.len() > 0);
    assert!(results[0].name.contains("firefox"));
}
```

### 2. Use Clippy Early
Run `cargo clippy` frequently to catch issues:
```bash
cargo clippy -- -W clippy::all
```

### 3. Document As You Go
Write rustdoc comments while coding:
```rust
/// Translates a Linux path to Windows path
///
/// # Examples
/// ```
/// let translator = PathTranslator::new();
/// let windows_path = translator.linux_to_windows("/nix/store/abc");
/// assert_eq!(windows_path, "C:\\Nix\\store\\abc");
/// ```
pub fn linux_to_windows(&self, linux_path: &str) -> String {
    // Implementation
}
```

### 4. Commit Often
Small, focused commits are better:
```bash
git commit -m "Add path translator with 10 test cases"
git commit -m "Implement nix search operation"
git commit -m "Add wrapper script generator"
```

### 5. Keep It Simple
Phase 1 is about foundations, not features:
- ✅ Simple, clean, testable code
- ✅ Good error messages
- ✅ Comprehensive tests
- ❌ Don't add GUI yet
- ❌ Don't optimize prematurely
- ❌ Don't add advanced features

---

## 🎯 Daily Goals (Week 1)

**Monday**: Repository setup, CLI skeleton
**Tuesday**: Finish CLI, start Nix operations
**Wednesday**: Complete Nix operations layer
**Thursday**: Path translation design
**Friday**: Path translation implementation
**Weekend**: Path translation tests, catch up

---

## 🎯 Daily Goals (Week 2)

**Monday**: Wrapper script templates
**Tuesday**: Complete wrapper generation
**Wednesday**: WSL2 bridge design doc
**Thursday**: Mock WSL2 implementation
**Friday**: Integration and testing
**Weekend**: Documentation, Phase 2 prep

---

## 🎉 End of Phase 1

**You will have**:
- ✅ Working CLI that can be ported to Windows
- ✅ All core logic implemented and tested
- ✅ Clear path to Phase 2 (real Windows testing)
- ✅ Confidence that architecture is sound

**Ready for Phase 2**:
- Boot to Windows
- Install WSL2 + Nix
- Replace mocks with real WSL2 calls
- Test with real packages
- Iterate based on real-world usage

---

**Let's build it!** 🚀

*Next: Start with Day 1-2 (Repository Setup & CLI Skeleton)*